\section{Improved Attack on Kuznyechik}\label{sec:other_target}

The flexibility of our techniques improves attacks against various other ciphers that use the partial sums technique. In this section, we demonstrate this by presenting an attack on 7-round Kuznyechik, which improves over the multiset-algebraic attack on the cipher presented in~\cite{TOSC:BirKhoPer16} by a factor of more than 80.  In the supplementary material of the full paper \cite{fullversion}, we present improved attacks on the full MISTY1 (App.~A), and variants of CLEFIA-128 with 11 and 12 rounds (App.~B). Our attacks on Kuznyechik and MISTY1 are the best known attacks on these ciphers. 

\subsection{The structure of Kuznyechik} 

The block cipher Kuznyechik~\cite{Kuznyechik} is the current encryption standard of the Russian Federation.  It is an SPN operating on a 128-bit state organized as a $4\times4$ array of 8-bit words. The key length is 256 bits, and the encryption process is composed of 9 rounds. Each round of Kuznyechik is composed of three operations: \begin{itemize} 
    \item[] \textbf{Substitution}. Apply an 8-bit S-box independently to every byte of the state; 
    \item[] \textbf{Linear Transformation}. Multiply the state by an invertible 16-by-16 matrix $M$ over $GF(2^8)$;
    \item[] \textbf{Key Addition}. XOR a 128-bit round key computed from the secret key to the state.
\end{itemize}
An additional key addition operation is applied before the first round. As properties of the key schedule of Kuznyechik are not used in this paper, we omit its description and refer the reader to~\cite{Kuznyechik}.

\subsection{The multiset-algebraic attack of Biryukov et al.} 

In~\cite{TOSC:BirKhoPer16}, Biryukov et al.~presented an algebraic attack on up to 7 rounds of Kuznyechik. The attack is based on the following observation: 
\begin{lemma}\label{Lem:Kuznyechik1}
Consider the encryption by 4-round Kuznyechik of a set of $2^{127}$ distinct plaintexts, $P^0,P^1,\ldots,P^{2^{127}-1}$, which form a subspace of degree 127 of $\{0,1\}^{128}$. Then the corresponding ciphertexts satisfy $\bigoplus_{i=0}^{2^{127}-1} C^i=0$.  
\end{lemma}
The attack uses Lemma~\ref{Lem:Kuznyechik1} in the same way as the Square attack on AES uses Lemma~\ref{Lem:Square1}. The adversary asks for the encryption of the entire codebook of $2^{128}$ plaintexts. Then he guesses a single byte of the whitening subkey and for each guess, he finds a set of $2^7$ values in that byte such that the corresponding values after the substitution operation form a 7-dimensional subspace of $\{0,1\}^8$. By taking these values along with all $2^{120}$ possible values in the other 15 bytes, the adversary obtains a set of $2^{127}$ plaintexts, whose corresponding intermediate values after one round satisfy the assumption of Lemma~\ref{Lem:Kuznyechik1}. 

By the lemma, the XOR of the corresponding values at the end of the 5'th round is zero. In order to check this, the adversary guesses some subkey bytes in the last two rounds and partially decrypts the ciphertexts to compute the XOR in a single byte at the end of the 5'th round. The situation is similar to the AES, with the `only' difference that since the linear transformation is a 16-by-16 matrix (and not a 4-by-4), one has to guess all 16 bytes of the last round subkey. The adversary guesses the last round subkey and one byte of the equivalent subkey of the penultimate round, partially decrypts the ciphertexts, and checks whether the values XOR to zero. Biryukov et al.~suggested to significantly speed up this procedure using partial sums. Borrowing the notation from Section~\ref{sec:sub:partial-sums}, the value of the byte in which the XOR should be computed can be written as: 
\begin{align}\label{Eq:Kuznyechik1}
  \begin{split}
x^5_0=S^{-1}(\bar{k}^5_0 \oplus e_0 \cdot &S^{-1}(C_0 \oplus k^6_0) \oplus e_1 \cdot S^{-1}(C_1 \oplus k^6_1) \oplus \ldots \\
&\oplus e_{14} \cdot S^{-1}(C_{14} \oplus k^6_{14}) \oplus e_{15} \cdot S^{-1}(C_{15} \oplus k^6_{15})),
  \end{split}  
\end{align}
where the constants $e_0,e_1,\ldots,e_{15}$ are obtained from the matrix $M^{-1}$ and the multiplication is defined over $GF(2^8)$. In the attack of Biryukov et al., the sum in the right hand side of~\eqref{Eq:Kuznyechik1} is computed using 16 steps of partial sums, where we begin with a list of $2^{128}$ binary indices which indicate the parity of occurrence of each ciphertext value, and at each step, another subkey byte $k^6_i$ is guessed and the size of the list is reduced by a factor of $2^8$. Like in the partial sums attack on the AES, the two outstanding steps are the first step in which two subkeys are guessed and the list is squeezed to a list of size $2^{120}$, and the last step in which the XOR of $2^8$ values is computed under the guess of 17 subkey bytes. 

The complexity of each step is $2^{144}$ S-box computations, and hence, the complexity of the entire procedure is $2^{148}$ S-box computations. Since the procedure provides only an 8-bit filtering, the adversary has to repeat it for each of the 16 bytes (and for each guess of the subkey byte at the first round). Therefore, the total time complexity of the attack is $2^{8} \cdot 16 \cdot 2^{148}=2^{160}$ S-box computations, which are equivalent (according to~\cite{TOSC:BirKhoPer16}) to $2^{154.5}$ encryptions.

The authors of~\cite{TOSC:BirKhoPer16} present also an attack on 6-round Kuznyechik. In this attack, they use the fact that for 3-round Kuznyechik, taking a vector space of degree 120 of plaintexts (instead of degree 127 above) is sufficient for guaranteeing that the ciphertexts XOR to zero. Hence, in order to attack 6-round Kuznyechik, an adversary can ask for the encryption of $2^{120}$ plaintexts which are equal in a single byte and assume all possible values in the other bytes. The corresponding intermediate values after one round form a vector space of degree 120, and hence, the corresponding intermediate values after 4 rounds XOR to zero. This allows applying the same attack like above, where the overall complexity is reduced by a factor of $2^8$ since there is no need to guess a subkey byte at the first round. Hence, the overall data complexity is $2^{120}$ chosen plaintexts and the time complexity is $2^{146.5}$ encryptions.

The attacks of~\cite{TOSC:BirKhoPer16} are the best known attacks on reduced-round Kuznyechik.

\subsection{Improvement using our technique} 

Just like for AES, we can replace each step of the partial sums procedure performed in~\cite{TOSC:BirKhoPer16} by computing  a convolution. We can compute several convolutions in parallel by embedding into $\mathbb{Z}$ as well as precompute two FFTs required for the first step and one FFT required for each subsequent step. However, we can only compute 6 FFTs in parallel rather than 7, as we need $2^{120}$ values to be correct in the first step.  This requires $s \ge 8$ and cannot accommodate 7 parallel FFTs; instead we use 6 parallel FFTs with $s=9$ which guarantees no overflow. The complexity of the first step is reduced to $2^{120} \cdot 16 \cdot 2^{16}/6=8/3 \cdot 2^{136}$ additions and the complexity of the subsequent steps is reduced to $2^{120} \cdot 2 \cdot 16 \cdot 2^{16}/6=16/3 \cdot 2^{136}$ additions. At the last step (which computes the XOR of the values) we have to compute FFTs for the 8 bits of the SBox individually, but we use FFTs on 8-bit functions (instead of 16-bit ones), we can pack 8 computations in parallel, and we can precompute an additional FFT and reuse it for the computations of the eight bits. Hence, its amortized complexity is $2^{128} \cdot (1+(1/8)) \cdot 8 \cdot 2^{8}=9 \cdot 2^{136}$ additions. We conclude that the analysis of a single set of $2^{127}$ ciphertexts, with a given guess of the whitening key, takes $(8/3+14\cdot 16/3+9)2^{136}= 259/3 \cdot 2^{136}= 2^{142.4}$ additions.

Instead of examining the other 15 bytes using the same set of $2^{127}$ ciphertexts, we may construct additional sets of $2^{127}$ ciphertexts by taking other 127-dimensional subspaces at the end of the first round (which is possible since we ask for the encryption of the entire codebook and guess a subkey byte at the first round) and examining their XOR at the same byte at the end of the 5'th round. Like in the case of AES, when we examine the XOR at the same byte for a second set of ciphertexts, the complexity of the last step becomes negligible (as it is performed only for a few possible values of the subkey). When a third set of ciphertexts is examined, the two last steps become negligible, etc. By using seven sets of $2^{127}$ ciphertexts and examining each of them in three bytes, the complexity of the attack becomes 
\begin{align*}
    &2^8 \cdot 2^{136} \cdot 1/3 \cdot \big((259+232+216+200+184+168+152)+\\&+(136+136+120+104+88+72+56)+
(40+40+24+8)\big)\\&=2^{144}\cdot 745=2^{153.5}
\end{align*} 
additions, which are equivalent to about $2^{148}$ encryptions -- a speedup by a factor of more than 80 compared to the attack of~\cite{TOSC:BirKhoPer16}.

The attack on 6-round Kuznyechik can be improved similarly. The only difference is that we cannot use additional sets of plaintexts without increasing the data complexity. Hence, for the same data complexity, the time complexity is reduced to $2^{146.4}$ additions, which are equivalent to $2^{140.9}$ encryptions -- a speedup by a factor of more than 40.

